package com.ak.appliance.nmis.comm.bytes;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.params.provider.Arguments;

import java.nio.ByteBuffer;
import java.util.stream.Stream;

import static org.junit.jupiter.params.provider.Arguments.arguments;

class NmisTestProvider {
  private static final int[] EMPTY_INTS = {};

  private NmisTestProvider() {
  }

  static Stream<Arguments> allOhmsMyoOff() {
    byte[][] expected = {
        {0x7E, (byte) 0x81, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07},
        {0x7E, (byte) 0x81, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x27},
        {0x7E, (byte) 0x81, 0x08, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x67},
        {0x7E, (byte) 0x81, 0x08, 0x1C, 0x1C, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x77},
        {0x7E, (byte) 0x81, 0x08, 0x1E, 0x1E, 0x1E, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x7F},
        {0x7E, (byte) 0x81, 0x08, 0x1F, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, (byte) 0x83},
        {0x7E, (byte) 0x81, 0x08, 0x3F, 0x3F, 0x3F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x03}
    };

    Assertions.assertEquals(expected.length, NmisRequest.Single.values().length);
    Arguments[] values = new Arguments[expected.length];
    for (int i = 0; i < expected.length; i++) {
      values[i] = arguments(
          NmisRequest.Single.values()[i].buildForAll(NmisRequest.MyoType.OFF, NmisRequest.MyoFrequency.OFF),
          expected[i]
      );
    }
    return Stream.of(values);
  }

  static Stream<Arguments> myo() {
    byte[][] expected = {
        {0x7E, (byte) 0x81, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x81, (byte) 0x81, (byte) 0x81, (byte) 0x81, 0x0B},
        {0x7E, (byte) 0x81, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x82, (byte) 0x82, (byte) 0x82, (byte) 0x82, 0x0F},
        {0x7E, (byte) 0x81, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x17},
        {0x7E, (byte) 0x81, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x88, (byte) 0x88, (byte) 0x88, (byte) 0x88, 0x27},
        {0x7E, (byte) 0x81, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x90, (byte) 0x90, (byte) 0x90, (byte) 0x90, 0x47}
    };

    NmisRequest.MyoFrequency[] frequencies = {NmisRequest.MyoFrequency.HZ_50, NmisRequest.MyoFrequency.HZ_100,
        NmisRequest.MyoFrequency.HZ_200, NmisRequest.MyoFrequency.HZ_500, NmisRequest.MyoFrequency.HZ_1000};
    Assertions.assertEquals(expected.length, frequencies.length);

    Arguments[] values = new Arguments[expected.length];
    for (int i = 0; i < expected.length; i++) {
      values[i] = arguments(NmisRequest.Single.Z_360.buildForAll(NmisRequest.MyoType.MV1, frequencies[i]), expected[i]);
    }
    return Stream.of(values);
  }

  static Stream<Arguments> sequence() {
    byte[][] expected = {
        {0x7E, (byte) 0x82, 0x08, 0x01, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x19},
        {0x7E, (byte) 0x82, 0x08, 0x02, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x1A},
        {0x7E, (byte) 0x82, 0x08, 0x03, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x1B},
        {0x7E, (byte) 0x82, 0x08, 0x04, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x1C},
        {0x7E, (byte) 0x82, 0x08, 0x05, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0x8D},
        {0x7E, (byte) 0x82, 0x08, 0x06, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0x8E},
        {0x7E, (byte) 0x82, 0x08, 0x07, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0x8F},
        {0x7E, (byte) 0x82, 0x08, 0x08, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0x90}
    };

    Assertions.assertEquals(expected.length, NmisRequest.Sequence.values().length);
    Arguments[] values = new Arguments[expected.length];
    for (int i = 0; i < expected.length; i++) {
      values[i] = arguments(NmisRequest.Sequence.values()[i].build(), expected[i]);
    }
    return Stream.of(values);
  }

  static Stream<Arguments> allOhmsMyoOffResponse() {
    //all inputs contain error in the first byte
    byte[][] input = {
        {0x01, 0x7E, (byte) 0x91, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17},
        {0x02, 0x7E, (byte) 0x91, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x37},
        {0x03, 0x7E, (byte) 0x91, 0x08, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x77},
        {0x04, 0x7E, (byte) 0x91, 0x08, 0x1C, 0x1C, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00, (byte) 0x87},
        {0x05, 0x7E, (byte) 0x91, 0x08, 0x1E, 0x1E, 0x1E, 0x1E, 0x00, 0x00, 0x00, 0x00, (byte) 0x8F},
        {0x06, 0x7E, (byte) 0x91, 0x08, 0x1F, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, (byte) 0x93},
        {0x07, 0x7E, (byte) 0x91, 0x08, 0x3F, 0x3F, 0x3F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x13}
    };

    Assertions.assertEquals(input.length, NmisRequest.Single.values().length);
    Arguments[] values = new Arguments[input.length];
    for (int i = 0; i < input.length; i++) {
      values[i] = arguments(
          NmisRequest.Single.values()[i].buildForAll(NmisRequest.MyoType.OFF, NmisRequest.MyoFrequency.OFF),
          input[i]
      );
    }
    return Stream.of(values);
  }

  static Stream<Arguments> myoResponse() {
    byte[][] input = {
        {0x7E, (byte) 0x91, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x81, (byte) 0x81, (byte) 0x81, (byte) 0x81, 0x1B},
        {0x7E, (byte) 0x91, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x82, (byte) 0x82, (byte) 0x82, (byte) 0x82, 0x1F},
        {0x7E, (byte) 0x91, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x27},
        {0x7E, (byte) 0x91, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x88, (byte) 0x88, (byte) 0x88, (byte) 0x88, 0x37},
        {0x7E, (byte) 0x91, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x90, (byte) 0x90, (byte) 0x90, (byte) 0x90, 0x57}
    };

    NmisRequest.MyoFrequency[] frequencies = {NmisRequest.MyoFrequency.HZ_50, NmisRequest.MyoFrequency.HZ_100,
        NmisRequest.MyoFrequency.HZ_200, NmisRequest.MyoFrequency.HZ_500, NmisRequest.MyoFrequency.HZ_1000};
    Assertions.assertEquals(input.length, frequencies.length);

    Arguments[] values = new Arguments[input.length];
    for (int i = 0; i < input.length; i++) {
      values[i] = arguments(NmisRequest.Single.Z_360.buildForAll(NmisRequest.MyoType.MV1, frequencies[i]), input[i]);
    }
    return Stream.of(values);
  }

  static Stream<Arguments> sequenceResponse() {
    byte[][] input = {
        {0x7E, (byte) 0x92, 0x08, 0x01, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x29},
        {0x7E, (byte) 0x92, 0x08, 0x02, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x2A},
        {0x7E, (byte) 0x92, 0x08, 0x03, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x2B},
        {0x7E, (byte) 0x92, 0x08, 0x04, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x2C},
        {0x7E, (byte) 0x92, 0x08, 0x05, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0x9D},
        {0x7E, (byte) 0x92, 0x08, 0x06, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0x9E},
        {0x7E, (byte) 0x92, 0x08, 0x07, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0x9F},
        {0x7E, (byte) 0x92, 0x08, 0x08, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0xA0}
    };

    Assertions.assertEquals(input.length, NmisRequest.Sequence.values().length);
    Arguments[] values = new Arguments[input.length];
    for (int i = 0; i < input.length; i++) {
      values[i] = arguments(NmisRequest.Sequence.values()[i].build(), input[i]);
    }
    return Stream.of(values);
  }

  static Stream<Arguments> nullResponse() {
    return Stream.of(
        arguments(
            ByteBuffer.wrap(new byte[] {0x7E, -12, 0x7E, 0x40, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xC7})
        )
    );
  }

  static Stream<Arguments> aliveAndChannelsResponse() {
    byte[][] input = {
        {0x7E, 0x41, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xC7},
        {0x7E, 0x42, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xC8},
        {0x7E, 0x43, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xC9},
        {0x7E, 0x44, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xCA},
    };
    NmisAddress[] addresses = {NmisAddress.CATCH_ELBOW, NmisAddress.ROTATE_ELBOW, NmisAddress.CATCH_HAND, NmisAddress.ROTATE_HAND};

    Assertions.assertEquals(input.length, addresses.length);
    Arguments[] values = new Arguments[input.length];
    for (int i = 0; i < input.length; i++) {
      values[i] = arguments(addresses[i], input[i]);
    }
    return Stream.of(values);
  }

  /**
   * <ol>
   * <li>
   * invalid START byte: 0x7A
   * </li>
   * <li>
   * invalid LEN byte: NmisProtocolByte.MAX_CAPACITY + 1
   * </li>
   * <li>
   * invalid LEN byte: -1
   * </li>
   * </ol>
   *
   * @return bytes to test
   */
  static Stream<Arguments> invalidTestByteResponse() {
    byte[][] input = {
        {0x7A, 0x41, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xC3},
        {0x7E, 0x42, NmisProtocolByte.MAX_CAPACITY + 1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0x01},
        {0x7E, 0x43, -1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xC0},
    };
    Arguments[] values = new Arguments[input.length];
    for (int i = 0; i < input.length; i++) {
      values[i] = arguments(ByteBuffer.wrap(input[i]));
    }
    return Stream.of(values);
  }

  static Stream<Arguments> invalidCRCResponse() {
    byte[][] input = {
        {0x7E, 0x41, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x7E, 0x42, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x7E, 0x43, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x7E, 0x44, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
    };
    Arguments[] values = new Arguments[input.length];
    for (int i = 0; i < input.length; i++) {
      values[i] = arguments(ByteBuffer.wrap(input[i]));
    }
    return Stream.of(values);
  }

  static Stream<Arguments> dataResponse() {
    return Stream.of(
        arguments(new byte[] {
            // NO Data, empty frame
            0x7e, 0x45, 0x02, 0x3f, 0x00, 0x04}, new int[] {0x3f}),
        arguments(new byte[] {
            0x7e, 0x45, 0x08, 0x3f, 0x00, 0x03, 0x04, 0x18, 0x32, (byte) 0xca, 0x74, (byte) 0x99}, new int[] {0x3f}),
        arguments(new byte[] {
            0x7e, 0x45, 0x09, 0x44, 0x00, 0x01, 0x05, 0x0b, (byte) 0xe0, (byte) 0xb1, (byte) 0xe1, 0x7a, 0x0d}, new int[] {0x44}),
        arguments(new byte[] {
            // NO Data, invalid frame
            0x7e, (byte) 0x92, 0x08, 0x01, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x29}, EMPTY_INTS)
    );
  }
}
