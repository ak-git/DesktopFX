package com.ak.hardware.nmis.comm.interceptor;

import org.testng.Assert;
import org.testng.annotations.DataProvider;

public class TnmiTestProvider {
  private TnmiTestProvider() {
  }

  @DataProvider(name = "allOhmsMyoOff")
  public static Object[][] ohms() {
    byte[][] expected = {
        {0x7E, (byte) 0x81, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07},
        {0x7E, (byte) 0x81, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x27},
        {0x7E, (byte) 0x81, 0x08, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x67},
        {0x7E, (byte) 0x81, 0x08, 0x1C, 0x1C, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x77},
        {0x7E, (byte) 0x81, 0x08, 0x1E, 0x1E, 0x1E, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x7F},
        {0x7E, (byte) 0x81, 0x08, 0x1F, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, (byte) 0x83},
        {0x7E, (byte) 0x81, 0x08, 0x3F, 0x3F, 0x3F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x03}
    };

    Assert.assertEquals(expected.length, TnmiRequest.Single.values().length);
    Object[][] values = new Object[expected.length][2];
    for (int i = 0; i < expected.length; i++) {
      values[i] = new Object[] {TnmiRequest.Single.values()[i].
          buildForAll(TnmiRequest.MyoType.OFF, TnmiRequest.MyoFrequency.OFF), expected[i]};
    }
    return values;
  }

  @DataProvider(name = "360OhmsMyoHz")
  public static Object[][] myo() {
    byte[][] expected = {
        {0x7E, (byte) 0x81, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x81, (byte) 0x81, (byte) 0x81, (byte) 0x81, 0x0B},
        {0x7E, (byte) 0x81, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x82, (byte) 0x82, (byte) 0x82, (byte) 0x82, 0x0F},
        {0x7E, (byte) 0x81, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x17},
        {0x7E, (byte) 0x81, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x88, (byte) 0x88, (byte) 0x88, (byte) 0x88, 0x27},
        {0x7E, (byte) 0x81, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x90, (byte) 0x90, (byte) 0x90, (byte) 0x90, 0x47}
    };

    TnmiRequest.MyoFrequency[] frequencies = {TnmiRequest.MyoFrequency.HZ_50, TnmiRequest.MyoFrequency.HZ_100,
        TnmiRequest.MyoFrequency.HZ_200, TnmiRequest.MyoFrequency.HZ_500, TnmiRequest.MyoFrequency.HZ_1000};
    Assert.assertEquals(expected.length, frequencies.length);

    Object[][] values = new Object[expected.length][2];
    for (int i = 0; i < expected.length; i++) {
      values[i] = new Object[] {TnmiRequest.Single.Z_360.buildForAll(TnmiRequest.MyoType.MV1, frequencies[i]), expected[i]};
    }
    return values;
  }

  @DataProvider(name = "sequence")
  public static Object[][] sequence() {
    byte[][] expected = {
        {0x7E, (byte) 0x82, 0x08, 0x01, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x19},
        {0x7E, (byte) 0x82, 0x08, 0x02, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x1A},
        {0x7E, (byte) 0x82, 0x08, 0x03, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x1B},
        {0x7E, (byte) 0x82, 0x08, 0x04, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x1C},
        {0x7E, (byte) 0x82, 0x08, 0x05, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0x8D},
        {0x7E, (byte) 0x82, 0x08, 0x06, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0x8E},
        {0x7E, (byte) 0x82, 0x08, 0x07, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0x8F},
        {0x7E, (byte) 0x82, 0x08, 0x08, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0x90}
    };

    Assert.assertEquals(expected.length, TnmiRequest.Sequence.values().length);
    Object[][] values = new Object[expected.length][2];
    for (int i = 0; i < expected.length; i++) {
      values[i] = new Object[] {TnmiRequest.Sequence.values()[i].build(), expected[i]};
    }
    return values;
  }

  @DataProvider(name = "allOhmsMyoOffResponse")
  public static Object[][] ohmsResponse() {
    //all inputs contain error in the first byte
    byte[][] input = {
        {0x01, 0x7E, (byte) 0x91, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17},
        {0x02, 0x7E, (byte) 0x91, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x37},
        {0x03, 0x7E, (byte) 0x91, 0x08, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x77},
        {0x04, 0x7E, (byte) 0x91, 0x08, 0x1C, 0x1C, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00, (byte) 0x87},
        {0x05, 0x7E, (byte) 0x91, 0x08, 0x1E, 0x1E, 0x1E, 0x1E, 0x00, 0x00, 0x00, 0x00, (byte) 0x8F},
        {0x06, 0x7E, (byte) 0x91, 0x08, 0x1F, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, (byte) 0x93},
        {0x07, 0x7E, (byte) 0x91, 0x08, 0x3F, 0x3F, 0x3F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x13}
    };

    Assert.assertEquals(input.length, TnmiRequest.Single.values().length);
    Object[][] values = new Object[input.length][2];
    for (int i = 0; i < input.length; i++) {
      values[i] = new Object[] {TnmiRequest.Single.values()[i].
          buildForAll(TnmiRequest.MyoType.OFF, TnmiRequest.MyoFrequency.OFF), input[i]};
    }
    return values;
  }

  @DataProvider(name = "360OhmsMyoHzResponse")
  public static Object[][] myoResponse() {
    byte[][] input = {
        {0x7E, (byte) 0x91, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x81, (byte) 0x81, (byte) 0x81, (byte) 0x81, 0x1B},
        {0x7E, (byte) 0x91, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x82, (byte) 0x82, (byte) 0x82, (byte) 0x82, 0x1F},
        {0x7E, (byte) 0x91, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x27},
        {0x7E, (byte) 0x91, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x88, (byte) 0x88, (byte) 0x88, (byte) 0x88, 0x37},
        {0x7E, (byte) 0x91, 0x08, 0x00, 0x00, 0x00, 0x00, (byte) 0x90, (byte) 0x90, (byte) 0x90, (byte) 0x90, 0x57}
    };

    TnmiRequest.MyoFrequency[] frequencies = {TnmiRequest.MyoFrequency.HZ_50, TnmiRequest.MyoFrequency.HZ_100,
        TnmiRequest.MyoFrequency.HZ_200, TnmiRequest.MyoFrequency.HZ_500, TnmiRequest.MyoFrequency.HZ_1000};
    Assert.assertEquals(input.length, frequencies.length);

    Object[][] values = new Object[input.length][2];
    for (int i = 0; i < input.length; i++) {
      values[i] = new Object[] {TnmiRequest.Single.Z_360.buildForAll(TnmiRequest.MyoType.MV1, frequencies[i]), input[i]};
    }
    return values;
  }

  @DataProvider(name = "sequenceResponse")
  public static Object[][] sequenceResponse() {
    byte[][] input = {
        {0x7E, (byte) 0x92, 0x08, 0x01, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x29},
        {0x7E, (byte) 0x92, 0x08, 0x02, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x2A},
        {0x7E, (byte) 0x92, 0x08, 0x03, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x2B},
        {0x7E, (byte) 0x92, 0x08, 0x04, 0x00, 0x00, 0x00, (byte) 0x84, (byte) 0x84, (byte) 0x84, (byte) 0x84, 0x2C},
        {0x7E, (byte) 0x92, 0x08, 0x05, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0x9D},
        {0x7E, (byte) 0x92, 0x08, 0x06, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0x9E},
        {0x7E, (byte) 0x92, 0x08, 0x07, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0x9F},
        {0x7E, (byte) 0x92, 0x08, 0x08, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x60, (byte) 0xA0}
    };

    Assert.assertEquals(input.length, TnmiRequest.Sequence.values().length);
    Object[][] values = new Object[input.length][2];
    for (int i = 0; i < input.length; i++) {
      values[i] = new Object[] {TnmiRequest.Sequence.values()[i].build(), input[i]};
    }
    return values;
  }

  @DataProvider(name = "aliveAndChannelsResponse")
  public static Object[][] aliveAndChannelsResponse() {
    byte[][] input = {
        {0x7E, -12, 0x7E, 0x40, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xC7},
        {0x7E, 0x41, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xC7},
        {0x7E, 0x42, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xC8},
        {0x7E, 0x43, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xC9},
        {0x7E, 0x44, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xCA},
    };
    TnmiAddress[] addresses = {TnmiAddress.ALIVE,
        TnmiAddress.CATCH_ELBOW, TnmiAddress.ROTATE_ELBOW, TnmiAddress.CATCH_HAND, TnmiAddress.ROTATE_HAND};

    Assert.assertEquals(input.length, addresses.length);
    Object[][] values = new Object[input.length][2];
    for (int i = 0; i < input.length; i++) {
      values[i] = new Object[] {addresses[i], input[i]};
    }
    return values;
  }

  /**
   * <ol>
   * <li>
   * invalid START byte: 0x7A
   * </li>
   * <li>
   * invalid LEN byte: TnmiProtocolByte.MAX_CAPACITY + 1
   * </li>
   * <li>
   * invalid LEN byte: -1
   * </li>
   * </ol>
   *
   * @return bytes to test
   */
  @DataProvider(name = "invalidTestByteResponse")
  public static Object[][] invalidTestByteResponse() {
    byte[][] input = {
        {0x7A, 0x41, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xC3},
        {0x7E, 0x42, TnmiProtocolByte.MAX_CAPACITY + 1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0x01},
        {0x7E, 0x43, -1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0xC0},
    };
    Object[][] values = new Object[input.length][2];
    for (int i = 0; i < input.length; i++) {
      values[i] = new Object[] {input[i]};
    }
    return values;
  }

  @DataProvider(name = "invalidCRCResponse")
  public static Object[][] invalidCRCResponse() {
    byte[][] input = {
        {0x7E, 0x41, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x7E, 0x42, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x7E, 0x43, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x7E, 0x44, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
    };
    Object[][] values = new Object[input.length][2];
    for (int i = 0; i < input.length; i++) {
      values[i] = new Object[] {input[i]};
    }
    return values;
  }
}
